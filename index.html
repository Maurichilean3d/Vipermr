
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Víbora MR (Quest 3) - Passthrough + Oclusión + Paredes</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background: transparent; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display:block; background: transparent !important; }

    #overlay {
      position: fixed; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      pointer-events: none; z-index: 10;
      gap: 14px;
    }
    #btn-ar {
      pointer-events: auto;
      padding: 14px 28px;
      background: #ffaa00;
      border: none;
      border-radius: 999px;
      font-weight: 900;
      font-size: 18px;
      color: #000;
      box-shadow: 0 0 22px rgba(255, 170, 0, 0.55);
      cursor: pointer;
    }
    #hud {
      pointer-events: none;
      display: none;
      position: absolute;
      top: 16px; left: 16px;
      color: #ffaa00;
      font-weight: 900;
      text-shadow: 0 0 10px rgba(0,0,0,0.85);
      font-size: 18px;
      line-height: 1.2;
      white-space: pre;
    }
    #hint {
      pointer-events: none;
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.9);
      font-size: 13px;
      display: none;
    }

    #damage {
      position: fixed; inset: 0;
      background: red;
      opacity: 0;
      pointer-events: none;
      transition: opacity 120ms;
      z-index: 20;
    }
  </style>
</head>
<body>

<div id="damage"></div>

<div id="overlay">
  <button id="btn-ar">INICIAR MR (Quest 3)</button>
  <div id="hud">ESQUIVADAS: 0\nNIVEL: 1 (Coralillo)</div>
  <div id="hint">Consejo: Muévete lateralmente y agáchate. Las víboras salen de paredes detectadas si el navegador lo soporta.</div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

////////////////////////////////////////////////////////////////////////////////
// 0) NOTAS IMPORTANTES
// - Esto DEBE correrse en HTTPS para que WebXR + depth funcione bien.
// - En Quest 3 usa Meta Quest Browser.
// - Passthrough: renderer alpha + clear alpha 0 + body/canvas transparent.
// - Oclusión: escribimos el depth real en el framebuffer XR (baseLayer.framebuffer)
//   y seteamos viewport por cada view.
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// 1) SHADERS DEPTH (escribimos SOLO en depth buffer)
//    Usamos textura RG8 (2 bytes) para compatibilidad WebGL2.
////////////////////////////////////////////////////////////////////////////////
const depthVS = `#version 300 es
in vec2 aPos;
out vec2 vUv;
void main() {
  vUv = aPos * 0.5 + 0.5;
  gl_Position = vec4(aPos, 0.0, 1.0);
}
`;

const depthFS = `#version 300 es
precision highp float;
precision highp sampler2D;

in vec2 vUv;
uniform sampler2D uDepth;
uniform float uRawToMeters;
uniform mat4 uProj;

out vec4 outColor;

// Depth Sensing Luminance-Alpha suele venir como 2 bytes (low/high).
// Con RG8 lo leemos como r,g.
float decodeRG(vec2 rg) {
  float lo = rg.x * 255.0;
  float hi = rg.y * 255.0;
  return hi * 256.0 + lo;
}

void main() {
  vec2 rg = texture(uDepth, vUv).rg;
  float raw = decodeRG(rg);
  float zMeters = raw * uRawToMeters;
  if (zMeters <= 0.0) discard;

  // z en cámara es negativo en OpenGL
  float z = -zMeters;

  // Pasamos de z lineal a depth buffer usando la proyección del view.
  float clipZ = uProj[2][2] * z + uProj[3][2];
  float clipW = uProj[2][3] * z + uProj[3][3];
  float ndcZ = clipZ / clipW;
  float depth = clamp(ndcZ * 0.5 + 0.5, 0.0, 1.0);

  gl_FragDepth = depth;
  outColor = vec4(0.0); // no color
}
`;

////////////////////////////////////////////////////////////////////////////////
// 2) THREE SETUP
////////////////////////////////////////////////////////////////////////////////
let camera, scene, renderer;
let xrSession = null, xrRefSpace = null, xrGlBinding = null;

// Depth occlusion GPU bits:
let depthProgram = null;
let depthVao = null;
let depthTex = null;
let depthEnabled = true;

// Plane detection (para “pared real”)
let planeDetectionSupported = false;

// Juego
const snakes = [];
const debris = [];
const cracks = [];
let lastSpawn = 0;
let spawnInterval = 2600;
let score = 0;
let level = 1;
let gameOverFlag = false;

// Player pos
const playerPos = new THREE.Vector3();

// Room fallback (virtual)
let roomGroup;

// UI
const btn = document.getElementById('btn-ar');
const hud = document.getElementById('hud');
const hint = document.getElementById('hint');
const dmg = document.getElementById('damage');

init();

function init() {
  scene = new THREE.Scene();
  scene.background = null;

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 30);

  // Luces para ver víboras
  const hemi = new THREE.HemisphereLight(0xffffff, 0x404040, 1.3);
  hemi.position.set(0, 2, 0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffaa55, 1.8);
  dir.position.set(2, 3, 1);
  scene.add(dir);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;

  // PASSTHROUGH: clave
  renderer.setClearColor(0x000000, 0);
  renderer.autoClear = true;

  document.body.appendChild(renderer.domElement);

  // Fallback: “habitación” virtual (suelo, techo, paredes)
  buildVirtualRoom();

  btn.addEventListener('click', startMR);
  window.addEventListener('resize', onResize);

  renderer.setAnimationLoop(render);
}

function buildVirtualRoom() {
  roomGroup = new THREE.Group();
  scene.add(roomGroup);

  const matFloor = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.95, metalness: 0.0 });
  const matCeil  = new THREE.MeshStandardMaterial({ color: 0x0b0b0b, roughness: 0.95, metalness: 0.0 });
  const matWall  = new THREE.MeshStandardMaterial({ color: 0x141414, roughness: 0.95, metalness: 0.0, transparent: true, opacity: 0.20 });

  // Tamaño “genérico”
  const W = 6.0, H = 2.8, D = 6.0;

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matFloor);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = 0;
  floor.receiveShadow = false;
  roomGroup.add(floor);

  const ceil = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matCeil);
  ceil.rotation.x = Math.PI / 2;
  ceil.position.y = H;
  roomGroup.add(ceil);

  const wallGeo = new THREE.PlaneGeometry(W, H);

  const wallN = new THREE.Mesh(wallGeo, matWall);
  wallN.position.set(0, H / 2, -D / 2);
  roomGroup.add(wallN);

  const wallS = new THREE.Mesh(wallGeo, matWall);
  wallS.rotation.y = Math.PI;
  wallS.position.set(0, H / 2, D / 2);
  roomGroup.add(wallS);

  const wallE = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
  wallE.rotation.y = -Math.PI / 2;
  wallE.position.set(W / 2, H / 2, 0);
  roomGroup.add(wallE);

  const wallW = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
  wallW.rotation.y = Math.PI / 2;
  wallW.position.set(-W / 2, H / 2, 0);
  roomGroup.add(wallW);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

////////////////////////////////////////////////////////////////////////////////
// 3) START MR (WebXR)
////////////////////////////////////////////////////////////////////////////////
async function startMR() {
  if (!navigator.xr) { alert("WebXR no está disponible."); return; }

  const supported = await navigator.xr.isSessionSupported('immersive-ar');
  if (!supported) {
    alert("immersive-ar no está soportado en este navegador/dispositivo.");
    return;
  }

  const sessionInit = {
    requiredFeatures: ['local-floor'],
    optionalFeatures: ['dom-overlay', 'depth-sensing', 'plane-detection'],
    domOverlay: { root: document.body },
    depthSensing: {
      usagePreference: ['cpu-optimized'],
      dataFormatPreference: ['luminance-alpha']
    }
  };

  try {
    xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
    renderer.xr.setSession(xrSession);

    xrSession.addEventListener('end', () => {
      xrSession = null;
      xrRefSpace = null;
      xrGlBinding = null;
      hud.style.display = 'none';
      hint.style.display = 'none';
      btn.style.display = 'block';
      resetGame();
    });

    xrRefSpace = await xrSession.requestReferenceSpace('local-floor');

    // Plane detection flag (si existe la propiedad)
    planeDetectionSupported = !!xrSession.detectedPlanes;

    initDepthOcclusion(xrSession);

    btn.style.display = 'none';
    hud.style.display = 'block';
    hint.style.display = 'block';

    resetGame();
  } catch (e) {
    console.error(e);
    alert("Error iniciando MR: " + e.message);
  }
}

////////////////////////////////////////////////////////////////////////////////
// 4) DEPTH OCCLUSION INIT
////////////////////////////////////////////////////////////////////////////////
function initDepthOcclusion(session) {
  const gl = renderer.getContext();

  // XRWebGLBinding
  xrGlBinding = new XRWebGLBinding(session, gl);

  // Compilar shaders
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, depthVS);
  gl.compileShader(vs);
  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
    console.error("Depth VS error:", gl.getShaderInfoLog(vs));
  }

  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, depthFS);
  gl.compileShader(fs);
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
    console.error("Depth FS error:", gl.getShaderInfoLog(fs));
  }

  depthProgram = gl.createProgram();
  gl.attachShader(depthProgram, vs);
  gl.attachShader(depthProgram, fs);
  gl.linkProgram(depthProgram);
  if (!gl.getProgramParameter(depthProgram, gl.LINK_STATUS)) {
    console.error("Depth program link error:", gl.getProgramInfoLog(depthProgram));
  }

  // Fullscreen quad
  depthVao = gl.createVertexArray();
  gl.bindVertexArray(depthVao);

  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,   1, -1,  -1,  1,
    -1,  1,   1, -1,   1,  1
  ]), gl.STATIC_DRAW);

  const loc = gl.getAttribLocation(depthProgram, 'aPos');
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

  // Depth texture (RG8)
  depthTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, depthTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}

////////////////////////////////////////////////////////////////////////////////
// 5) GAME: LEVELS, SNAKES, CRACKS, DEBRIS
////////////////////////////////////////////////////////////////////////////////
function resetGame() {
  score = 0;
  level = 1;
  spawnInterval = 2600;
  lastSpawn = 0;
  gameOverFlag = false;

  // limpiar
  for (const s of snakes) scene.remove(s.group);
  snakes.length = 0;

  for (const d of debris) scene.remove(d.mesh);
  debris.length = 0;

  for (const c of cracks) scene.remove(c.mesh);
  cracks.length = 0;

  updateHud();
}

function updateHud() {
  const name =
    level === 1 ? "Coralillo" :
    level === 2 ? "Cascabel" :
    level === 3 ? "Mamba" :
    "Boa (Jefe)";

  hud.textContent = `ESQUIVADAS: ${score}\nNIVEL: ${level} (${name})`;
}

function computeLevelFromScore(sc) {
  // 0-6 coralillo, 7-14 cascabel, 15-24 mamba, 25+ boa jefe
  if (sc < 7) return 1;
  if (sc < 15) return 2;
  if (sc < 25) return 3;
  return 4;
}

function getSnakeConfig(lvl) {
  // Ajusta a gusto
  if (lvl === 1) return { speed: 4.2, scale: 0.75, colorBody: 0xff2a2a, colorHead: 0x111111, damageRadius: 0.28 };
  if (lvl === 2) return { speed: 4.8, scale: 0.85, colorBody: 0xc2a22a, colorHead: 0x3b2a16, damageRadius: 0.30 };
  if (lvl === 3) return { speed: 5.4, scale: 0.95, colorBody: 0x1fd16a, colorHead: 0x0a2b14, damageRadius: 0.32 };
  return            { speed: 3.2, scale: 1.55, colorBody: 0x5d4037, colorHead: 0x2e7d32, damageRadius: 0.42 };
}

function spawnCrack(worldPos, worldQuat) {
  // “Pared se triza” (un plane con textura procedural simple)
  const geo = new THREE.PlaneGeometry(0.55, 0.55);
  const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0, depthWrite: false });
  const mesh = new THREE.Mesh(geo, mat);

  mesh.position.copy(worldPos);
  mesh.quaternion.copy(worldQuat);

  // Separarlo un poquito hacia el jugador para que se vea
  const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(worldQuat);
  mesh.position.add(forward.multiplyScalar(0.01));

  // Dibujamos encima
  mesh.renderOrder = 999;

  // Creamos una textura canvas con grietas rápidas
  const canvas = document.createElement('canvas');
  canvas.width = 256; canvas.height = 256;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,256,256);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.85)';
  ctx.lineWidth = 3;

  function crackLine(x,y, len, ang, depth) {
    if (depth <= 0) return;
    const x2 = x + Math.cos(ang) * len;
    const y2 = y + Math.sin(ang) * len;
    ctx.beginPath();
    ctx.moveTo(x,y); ctx.lineTo(x2,y2);
    ctx.stroke();
    // ramas
    const branches = 1 + Math.floor(Math.random()*3);
    for (let i=0;i<branches;i++) {
      const a2 = ang + (Math.random()-0.5) * 1.2;
      crackLine(x2, y2, len * (0.45 + Math.random()*0.35), a2, depth-1);
    }
  }
  for (let i=0;i<6;i++){
    const a = Math.random() * Math.PI * 2;
    crackLine(128, 128, 60 + Math.random()*40, a, 3);
  }

  ctx.fillStyle = 'rgba(255,255,255,0.30)';
  ctx.fillRect(0,0,256,256);

  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;

  mat.map = tex;
  mat.needsUpdate = true;

  scene.add(mesh);
  cracks.push({ mesh, t: 0 });
}

function spawnDebris(worldPos, worldQuat, intensity = 1.0) {
  const count = Math.floor(10 * intensity);
  for (let i = 0; i < count; i++) {
    const geo = new THREE.BoxGeometry(0.035, 0.035, 0.035);
    const mat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 1.0, metalness: 0.0 });
    const m = new THREE.Mesh(geo, mat);

    m.position.copy(worldPos);
    m.position.x += (Math.random() - 0.5) * 0.25;
    m.position.y += (Math.random() - 0.5) * 0.25;
    m.position.z += (Math.random() - 0.5) * 0.25;

    const outward = new THREE.Vector3(0, 0, 1).applyQuaternion(worldQuat).normalize();
    const v = outward.multiplyScalar(1.8 + Math.random() * 2.4);
    v.add(new THREE.Vector3((Math.random()-0.5)*1.2, (Math.random()-0.2)*1.5, (Math.random()-0.5)*1.2));

    scene.add(m);
    debris.push({ mesh: m, vel: v, life: 0.9 + Math.random() * 0.4 });
  }
}

function createSnakeMesh(cfg) {
  const group = new THREE.Group();

  // cabeza
  const headGeo = new THREE.ConeGeometry(0.09 * cfg.scale, 0.22 * cfg.scale, 10);
  headGeo.rotateX(-Math.PI / 2);
  const headMat = new THREE.MeshStandardMaterial({ color: cfg.colorHead, roughness: 0.35, metalness: 0.0 });
  const head = new THREE.Mesh(headGeo, headMat);
  group.add(head);

  // cuerpo
  const bodyGeo = new THREE.CylinderGeometry(0.065 * cfg.scale, 0.045 * cfg.scale, 1.55 * cfg.scale, 10);
  bodyGeo.rotateX(-Math.PI / 2);
  bodyGeo.translate(0, 0, -0.78 * cfg.scale);
  const bodyMat = new THREE.MeshStandardMaterial({ color: cfg.colorBody, roughness: 0.45, metalness: 0.0 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  group.add(body);

  return group;
}

// Spawnear desde pared real si hay planes; si no, fallback “pared circular”
const tmpMat4 = new THREE.Matrix4();
const tmpQuat = new THREE.Quaternion();
const tmpPos  = new THREE.Vector3();

function pickWallSpawn(frame) {
  // Si plane detection está disponible, intentamos agarrar un plano vertical
  if (planeDetectionSupported && xrSession?.detectedPlanes && frame) {
    // Elegimos al azar entre planes verticales
    const planes = Array.from(xrSession.detectedPlanes);
    if (planes.length) {
      // shuffle simple (intento varias veces)
      for (let tries = 0; tries < 10; tries++) {
        const p = planes[(Math.random() * planes.length) | 0];
        const pose = frame.getPose(p.planeSpace, xrRefSpace);
        if (!pose) continue;

        // Heurística: si “up” del plano NO es vertical, probablemente es pared.
        // Tomamos la normal del plano como eje Z local del planeSpace en WebXR.
        tmpMat4.fromArray(pose.transform.matrix);
        tmpQuat.setFromRotationMatrix(tmpMat4);
        tmpPos.setFromMatrixPosition(tmpMat4);

        // “up” del plano en mundo
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(tmpQuat).normalize();

        // Si el up está cerca del mundo-up, es suelo/techo. Si no, es pared.
        const dot = Math.abs(up.dot(new THREE.Vector3(0,1,0)));
        const looksLikeWall = dot < 0.55; // pared => up no alineado con Y

        if (!looksLikeWall) continue;

        // Posición base: centro del plano
        const spawnPos = tmpPos.clone();
        // Empujamos un poco hacia fuera del plano, hacia el usuario, para que “salga”
        const outward = new THREE.Vector3(0,0,1).applyQuaternion(tmpQuat).normalize();
        spawnPos.add(outward.multiplyScalar(0.02));

        // Orientación: mirando al jugador (más agresivo) pero “pegado” a pared
        const lookQuat = new THREE.Quaternion();
        const look = new THREE.Matrix4().lookAt(spawnPos, playerPos, new THREE.Vector3(0,1,0));
        lookQuat.setFromRotationMatrix(look);

        // Para la grieta usamos la orientación del plano (se ve en la pared)
        const crackQuat = tmpQuat.clone();

        return { spawnPos, lookQuat, crackQuat };
      }
    }
  }

  // Fallback: “pared imaginaria” a radio fijo
  const angle = Math.random() * Math.PI * 2;
  const radius = 2.4;
  const height = 0.65 + Math.random() * 1.35;

  const spawnPos = new THREE.Vector3(
    Math.cos(angle) * radius,
    height,
    Math.sin(angle) * radius
  );

  const look = new THREE.Matrix4().lookAt(spawnPos, playerPos, new THREE.Vector3(0,1,0));
  const lookQuat = new THREE.Quaternion().setFromRotationMatrix(look);

  // “crack” orientada mirando al jugador
  const crackQuat = lookQuat.clone();

  return { spawnPos, lookQuat, crackQuat };
}

function spawnSnake(frame) {
  if (!xrSession || gameOverFlag) return;

  level = computeLevelFromScore(score);
  const cfg = getSnakeConfig(level);

  const { spawnPos, lookQuat, crackQuat } = pickWallSpawn(frame);

  // Crack primero (se triza), luego sale la víbora (con delay corto)
  spawnCrack(spawnPos, crackQuat);
  spawnDebris(spawnPos, crackQuat, level === 4 ? 1.8 : 1.0);

  const snakeMesh = createSnakeMesh(cfg);
  snakeMesh.position.copy(spawnPos);
  snakeMesh.quaternion.copy(lookQuat);

  // Empieza “metida” (retrocede hacia pared) y sale violentamente
  const backward = new THREE.Vector3(0, 0, -1).applyQuaternion(lookQuat).normalize();
  snakeMesh.position.add(backward.multiplyScalar(0.35));

  scene.add(snakeMesh);

  // Velocidad: hacia el jugador
  const dir = new THREE.Vector3().subVectors(playerPos, snakeMesh.position).normalize();
  const vel = dir.multiplyScalar(cfg.speed);

  snakes.push({
    group: snakeMesh,
    vel,
    cfg,
    phase: 0,      // 0 emerge, 1 ataque
    t: 0,
    spawnPos: snakeMesh.position.clone()
  });
}

function doGameOver() {
  if (gameOverFlag) return;
  gameOverFlag = true;

  dmg.style.opacity = 0.75;
  setTimeout(() => dmg.style.opacity = 0.0, 180);

  hud.textContent = `¡MORDIDO!\nReiniciando...`;
  setTimeout(() => resetGame(), 1400);
}

////////////////////////////////////////////////////////////////////////////////
// 6) UPDATE LOOP
////////////////////////////////////////////////////////////////////////////////
function update(delta, now, frame) {
  if (!xrSession) return;

  // player position
  camera.getWorldPosition(playerPos);

  // Dificultad
  level = computeLevelFromScore(score);
  const base = level === 4 ? 1200 : 2400;
  spawnInterval = Math.max(650, base - score * 55);

  // Spawn
  if (!gameOverFlag && (now - lastSpawn) > spawnInterval) {
    // En niveles más altos, spawnea más de una a veces
    const extra = (level >= 3 && Math.random() < 0.35) ? 1 : 0;
    spawnSnake(frame);
    if (extra) setTimeout(() => spawnSnake(frame), 180);
    lastSpawn = now;
    updateHud();
  }

  // Cracks anim (fade in/out)
  for (let i = cracks.length - 1; i >= 0; i--) {
    const c = cracks[i];
    c.t += delta;
    const aIn = Math.min(1, c.t / 0.12);
    const aOut = c.t > 0.35 ? Math.max(0, 1 - (c.t - 0.35) / 0.35) : 1;
    c.mesh.material.opacity = 0.85 * aIn * aOut;
    c.mesh.scale.setScalar(1 + 0.35 * Math.min(1, c.t / 0.25));
    if (c.t > 0.75) {
      scene.remove(c.mesh);
      cracks.splice(i, 1);
    }
  }

  // Debris
  for (let i = debris.length - 1; i >= 0; i--) {
    const d = debris[i];
    d.life -= delta;
    d.vel.y -= 2.2 * delta; // gravedad
    d.mesh.position.addScaledVector(d.vel, delta);
    d.mesh.rotation.x += 5 * delta;
    d.mesh.rotation.y += 4 * delta;
    if (d.life <= 0) {
      scene.remove(d.mesh);
      debris.splice(i, 1);
    }
  }

  // Snakes
  for (let i = snakes.length - 1; i >= 0; i--) {
    const s = snakes[i];
    s.t += delta;

    // “Emerger” rápido al inicio
    if (s.phase === 0) {
      const k = Math.min(1, s.t / 0.18);
      // avanza hacia delante local (sale de la pared)
      const forward = new THREE.Vector3(0,0,1).applyQuaternion(s.group.quaternion).normalize();
      s.group.position.addScaledVector(forward, (delta * (2.8 + s.cfg.speed)) * (1.2 - 0.7*k));
      if (s.t > 0.18) {
        s.phase = 1;
        s.t = 0;
      }
    } else {
      // Ataque: persigue al jugador (con leve “zigzag”)
      const desired = new THREE.Vector3().subVectors(playerPos, s.group.position).normalize();
      const zig = new THREE.Vector3(Math.sin(now * 0.006 + i), 0, Math.cos(now * 0.006 + i)).multiplyScalar(0.08);
      desired.add(zig).normalize();

      // suavizado de velocidad
      const targetVel = desired.multiplyScalar(s.cfg.speed);
      s.vel.lerp(targetVel, 0.07);

      s.group.position.addScaledVector(s.vel, delta);

      // Orientación hacia movimiento
      const look = new THREE.Matrix4().lookAt(s.group.position, playerPos, new THREE.Vector3(0,1,0));
      const q = new THREE.Quaternion().setFromRotationMatrix(look);
      s.group.quaternion.slerp(q, 0.10);

      // Ondulación visual
      s.group.rotation.z += Math.sin(now * 0.02 + i) * 0.002;

      // Colisión
      const dist = s.group.position.distanceTo(playerPos);
      if (!gameOverFlag && dist < s.cfg.damageRadius) {
        doGameOver();
        return;
      }

      // “Esquive” si pasó cerca y se aleja
      const away = s.group.position.distanceTo(playerPos);
      if (away > 6.0) {
        scene.remove(s.group);
        snakes.splice(i, 1);
      }

      // Si se fue “por detrás” del jugador, cuenta como esquivada
      // Heurística: si ya estuvo cerca y ahora se aleja bastante.
      if (s.t > 0.55 && away > 3.2) {
        scene.remove(s.group);
        snakes.splice(i, 1);
        score++;
        updateHud();
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// 7) RENDER + DEPTH OCCLUSION PASS
////////////////////////////////////////////////////////////////////////////////
function render(time, frame) {
  const now = performance.now();
  const delta = Math.min(0.05, renderer.clock ? renderer.clock.getDelta() : 0.016);

  // Update game (si estamos en XR frame)
  if (frame) update(delta, now, frame);

  // Depth occlusion pass
  if (frame && xrSession && depthEnabled && xrGlBinding && depthProgram) {
    const gl = renderer.getContext();
    const pose = frame.getViewerPose(xrRefSpace);
    const glLayer = xrSession.renderState.baseLayer;

    if (pose && glLayer) {
      // Escribimos depth en el framebuffer XR
      gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);

      gl.useProgram(depthProgram);

      const uDepthLoc = gl.getUniformLocation(depthProgram, 'uDepth');
      const uRawLoc   = gl.getUniformLocation(depthProgram, 'uRawToMeters');
      const uProjLoc  = gl.getUniformLocation(depthProgram, 'uProj');

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, depthTex);
      gl.uniform1i(uDepthLoc, 0);

      gl.bindVertexArray(depthVao);

      // Solo depth (sin color)
      gl.colorMask(false, false, false, false);
      gl.disable(gl.BLEND);
      gl.enable(gl.DEPTH_TEST);
      gl.depthMask(true);

      let wroteAny = false;

      for (const view of pose.views) {
        // Viewport por ojo/vista
        const vp = glLayer.getViewport(view);
        gl.viewport(vp.x, vp.y, vp.width, vp.height);

        // Obtener depth info (intentamos ambas rutas)
        let dInfo = null;
        try {
          // algunos navegadores prefieren frame.getDepthInformation
          if (frame.getDepthInformation) dInfo = frame.getDepthInformation(view);
        } catch (_) {}

        if (!dInfo) {
          try {
            dInfo = xrGlBinding.getDepthInformation(view);
          } catch (_) {}
        }

        if (!dInfo || !dInfo.data) continue;

        wroteAny = true;

        // Subir textura RG8
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.bindTexture(gl.TEXTURE_2D, depthTex);

        // En muchos casos dInfo.data es Uint8Array con 2 bytes por pixel.
        // Subimos como RG8 para WebGL2.
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RG8,
          dInfo.width,
          dInfo.height,
          0,
          gl.RG,
          gl.UNSIGNED_BYTE,
          dInfo.data
        );

        gl.uniform1f(uRawLoc, dInfo.rawValueToMeters);
        gl.uniformMatrix4fv(uProjLoc, false, view.projectionMatrix);

        // Dibujar quad fullscreen => escribe depth
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      // Reactivar color para Three
      gl.colorMask(true, true, true, true);

      // Si no escribió depth, no pasa nada (solo MR sin oclusión)
      // Three renderiza normalmente abajo.
    }
  }

  // Render normal (Three)
  renderer.render(scene, camera);
}

</script>
</body>
</html>
